## Context

Phase 1 scaffold is complete. The DDD layer directories exist but contain no logic. The technical design (`docs/technical_design.md`) defines the schema source of truth (`shared/schema/`), domain glossary, invariants, and error taxonomy. The product requirements define book upload, page-aware Q&A, and multi-provider support. This phase implements the data foundation for the Python CLI.

## Goals / Non-Goals

**Goals:**

- Create the initial SQL migration with books, chunks, and chat_messages tables
- Implement domain models (Book, Chunk, ChatMessage) that enforce all cross-platform invariants
- Implement typed error hierarchy (BookError, LLMError, StorageError) matching the error taxonomy
- Define repository protocols in the domain layer (no infrastructure imports)
- Implement a migration runner that applies numbered SQL files from `shared/schema/`
- Implement SQLite-backed repositories with full test coverage

**Non-Goals:**

- No embedding/vector tables — Phase 4 will add `002_add_embeddings.sql` with sqlite-vec
- No CLI commands — Phase 3+ (ingestion commands need parser + chunker first)
- No book parsing or chunking logic — Phase 3
- No LLM or embedding provider implementations — Phase 4-6
- No prompt templates — Phase 6
- No Swift implementations — Phase 8

## Decisions

### 1. Dataclasses for domain models, not Pydantic

Domain models use Python `dataclasses`, not Pydantic `BaseModel`. The domain layer must have zero external dependencies — it depends only on the standard library and its own protocols.

Pydantic is already used in `infra/settings.py` for environment variable validation, which is the correct layer for it.

**Alternative:** Pydantic models everywhere. Couples domain to an infrastructure library. Violates the dependency rule (domain has no outward dependencies).

### 2. Book is the aggregate root; Chunk access is scoped

Book is the aggregate root. Chunks belong to a Book and cannot exist independently. The domain invariant "a Chunk always belongs to exactly one Book" is enforced by the schema (FK with CASCADE DELETE) and the repository API.

However, ChunkRepository exists as a separate protocol because:
- Phase 3 (ingestion) needs to bulk-insert chunks after parsing
- Phase 5 (retrieval) needs to query chunks by page range for vector search
- Keeping chunk storage separate avoids a god-object BookRepository

External code accesses chunks via ChunkRepository but always scoped to a `book_id`.

**Alternative:** All chunk operations through BookRepository. Makes BookRepository too large and mixes write (ingestion) and read (retrieval) concerns.

### 3. String UUIDs for entity IDs

All entity IDs are `str` (UUID v4), generated by the application at creation time — not auto-incremented by the database. Both Python (`uuid.uuid4()`) and Swift (`UUID()`) generate compatible UUIDs.

The `id TEXT PRIMARY KEY` pattern works identically in SQLite for both platforms.

**Alternative:** Auto-incrementing integers. Ties identity to the database, makes cross-platform ID generation impossible, complicates testing (IDs are unpredictable).

### 4. SQLite with WAL mode and foreign keys enabled

The database connection enables:
- WAL mode (`PRAGMA journal_mode=WAL`) — better concurrent read performance
- Foreign keys (`PRAGMA foreign_keys=ON`) — enforces referential integrity (CASCADE DELETE)

These pragmas must be set on every new connection.

**Alternative:** Default journal mode. Worse read performance; no practical benefit for a local-only app.

### 5. Simple migration runner over Alembic

A custom migration runner that:
1. Reads `shared/schema/*.sql` files matching the pattern `NNN_name.sql`
2. Tracks applied migrations in a `schema_migrations` table
3. Applies only unapplied migrations in numerical order

This is ~50 lines of Python. Both the CLI and Swift app need the same logic, so it must be simple enough to reimplement in Swift.

**Alternative:** Alembic. Python-specific, generates Python migration files, cannot be shared with Swift. Overkill for numbered SQL files.

### 6. ISO 8601 timestamps as TEXT

SQLite has no native datetime type. All timestamps are stored as ISO 8601 strings (e.g., `"2026-02-15T10:30:00+00:00"`). Both Python (`datetime.isoformat()`) and Swift (`ISO8601DateFormatter`) handle this natively.

Column defaults use SQLite's `datetime('now')` function for database-generated timestamps.

**Alternative:** Unix timestamps (integers). Less readable in sqlite3 CLI, harder to debug, no timezone info.

### 7. Explicit status transitions on Book

Book status transitions are enforced by named methods, not by setting the field directly:
- `start_ingestion()`: pending → ingesting
- `complete_ingestion()`: ingesting → ready
- `fail_ingestion()`: ingesting → failed
- `reset_to_pending()`: any → pending (used for re-ingestion or provider switch)

Invalid transitions (e.g., pending → ready) raise `BookError`. This makes the aggregate root the single authority on valid state changes.

**Alternative:** Open `status` field that anyone can set. Allows invalid transitions, scatters business rules.

## Risks / Trade-offs

- **Schema may need columns we haven't anticipated** (e.g., `file_path`, `file_hash`) → Phase 3 will add a `002_*.sql` migration if needed. Keeping the initial schema minimal reduces premature decisions.
- **No embedding table yet** → sqlite-vec virtual tables have a different syntax than regular tables. Deferring to Phase 4 avoids coupling the initial schema to sqlite-vec specifics.
- **Migration runner is custom code** → It's simple (~50 lines) and must be reimplemented in Swift anyway. The alternative (Alembic) is Python-only and generates Python files.
- **Dataclass limitations** (no auto-validation on assignment) → Invariants are enforced in `__post_init__` and transition methods. Property setters are not used — mutations go through named methods.
